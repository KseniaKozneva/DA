\section{Тест производительности}
Для оценки эффективности реализованной поразрядной сортировки было проведено сравнение со стандартной сортировкой \texttt{std::sort} из библиотеки C++.

\textbf{Методика тестирования}

\begin{itemize}
\item \textbf{Генерация данных:} случайные ключи в формате автомобильных номеров \texttt{A 999 BC} (буквы латинского алфавита, цифры) и случайные значения длиной до 64 символов.
\item \textbf{Размеры выборок:} от 100\,000 до 1\,000\,000 элементов с шагом 100\,000.
\item \textbf{Измерения:} для каждого размера проводился однократный запуск. Измерялось только время сортировки (без учёта ввода-вывода и генерации данных).
\end{itemize}

\textbf{Результаты тестирования}

Был написан специальный бенчмарк, который генерирует тестовые данные и замеряет время работы обеих сортировок.

\begin{verbatim}
PS C:\Users\Administrator\Desktop\report_pattern> g++ benchmark.cpp -o benchmark.exe
PS C:\Users\Administrator\Desktop\report_pattern> .\benchmark.exe
Running benchmark...

n = 100000   RadixSort: 197.713 ms   std::sort: 238.381 ms   speedup: 1.21x
n = 200000   RadixSort: 445.540 ms   std::sort: 494.019 ms   speedup: 1.11x
n = 300000   RadixSort: 485.016 ms   std::sort: 761.226 ms   speedup: 1.57x
n = 400000   RadixSort: 567.417 ms   std::sort: 769.369 ms   speedup: 1.36x
n = 500000   RadixSort: 735.969 ms   std::sort: 990.981 ms   speedup: 1.35x
n = 600000   RadixSort: 944.123 ms   std::sort: 1188.150 ms  speedup: 1.26x
n = 700000   RadixSort: 1051.190 ms  std::sort: 1391.540 ms  speedup: 1.32x
n = 800000   RadixSort: 1210.400 ms  std::sort: 1623.620 ms  speedup: 1.34x
n = 900000   RadixSort: 1352.810 ms  std::sort: 1821.060 ms  speedup: 1.35x
n = 1000000  RadixSort: 1527.730 ms  std::sort: 2044.920 ms  speedup: 1.34x
\end{verbatim}

\textbf{Графическое представление}

\begin{figure}[h]
\centering
\begin{tikzpicture}
\begin{axis}[
    title={Сравнение времени сортировки},
    xlabel={Размер входных данных},
    ylabel={Время (мс)},
    legend pos=north west,
    grid=major,
    width=0.9\textwidth,
    height=0.45\textwidth,
    xtick={100000,200000,300000,400000,500000,600000,700000,800000,900000,1000000},
    xticklabels={100k,200k,300k,400k,500k,600k,700k,800k,900k,1M},
    scaled x ticks=false
]
\addplot[color=blue,mark=*] coordinates {
    (100000,197.713)
    (200000,445.540)
    (300000,485.016)
    (400000,567.417)
    (500000,735.969)
    (600000,944.123)
    (700000,1051.190)
    (800000,1210.400)
    (900000,1352.810)
    (1000000,1527.730)
};
\addplot[color=red,mark=square] coordinates {
    (100000,238.381)
    (200000,494.019)
    (300000,761.226)
    (400000,769.369)
    (500000,990.981)
    (600000,1188.150)
    (700000,1391.540)
    (800000,1623.620)
    (900000,1821.060)
    (1000000,2044.920)
};
\legend{RadixSort, std::sort}
\end{axis}
\end{tikzpicture}
\caption{Зависимость времени сортировки от размера входных данных}
\end{figure}

\textbf{Анализ результатов}

\begin{itemize}
\item \textbf{Линейная сложность:} Время работы поразрядной сортировки демонстрирует линейный рост с увеличением количества элементов. При увеличении размера данных в 10 раз (от 100\,000 до 1\,000\,000) время выполнения возрастает с 197.7 мс до 1527.7 мс, что соответствует росту примерно в 7.7 раза --- это близко к теоретической линейной зависимости с учётом накладных расходов.

\item \textbf{Сравнение с std::sort:} На всех размерах выборки поразрядная сортировка показывает лучшее время работы, чем стандартная сортировка. Ускорение варьируется от 1.11x до 1.57x, причём наибольший выигрыш (1.57x) достигается на размере 300\,000 элементов. Среднее ускорение по всем размерам составляет примерно 1.3x.

\item \textbf{Эффективность поразрядной сортировки:} Алгоритм эффективно использует фиксированную длину ключа (8 символов) и малый алфавит (256 символов), что позволяет обходиться без дорогостоящих операций сравнения строк. Вместо сравнений используются простые операции индексации в массиве счётчиков.
\end{itemize}
\pagebreak